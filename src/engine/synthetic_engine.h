#pragma once
#include "matching_engine.h"
#include "pcap_reader.h"
#include "../sbe/mdp3_messages.h"
#include "../common/types.h"
#include <unordered_map>
#include <vector>
#include <thread>
#include <atomic>
#include <mutex>
#include <functional>
#include <random>

namespace cme::sim {

struct BBO {
    Price best_bid;
    Quantity bid_size = 0;
    Price best_ask;
    Quantity ask_size = 0;
};

class SyntheticEngine : public IMatchingEngine {
public:
    SyntheticEngine(const std::string& pcap_path, double speed_multiplier = 1.0);
    ~SyntheticEngine() override;

    // IMatchingEngine interface
    std::vector<EngineEvent> submitOrder(std::unique_ptr<Order> order) override;
    std::vector<EngineEvent> cancelOrder(OrderId order_id, SecurityId security_id, uint64_t session_uuid) override;
    std::vector<EngineEvent> modifyOrder(OrderId order_id, SecurityId security_id, Price new_price, Quantity new_qty, ClOrdId new_cl_ord_id) override;

    // Start/stop pcap replay
    void startReplay();
    void stopReplay();

    // Set callback for forwarding replayed market data to publisher
    using MarketDataCallback = std::function<void(const char* data, size_t len)>;
    void setMarketDataCallback(MarketDataCallback cb);

    // Configuration
    void setFillProbability(double prob); // 0.0 to 1.0
    void setFillLatencyNs(uint64_t latency_ns);

    // Get BBO for an instrument
    BBO getBBO(SecurityId security_id) const;

private:
    PcapReader pcap_reader_;
    double speed_multiplier_;
    double fill_probability_ = 1.0;
    uint64_t fill_latency_ns_ = 1000;

    // BBO tracking per instrument
    mutable std::mutex bbo_mutex_;
    std::unordered_map<SecurityId, BBO> bbos_;

    // Resting orders waiting for fills
    struct RestingOrder {
        std::unique_ptr<Order> order;
        Timestamp submit_time;
    };
    mutable std::mutex orders_mutex_;
    std::unordered_map<OrderId, RestingOrder> resting_orders_;
    std::unordered_map<SecurityId, std::vector<OrderId>> orders_by_security_;

    uint64_t next_order_id_ = 1;
    uint64_t next_trade_id_ = 1;

    MarketDataCallback md_callback_;

    // Replay thread
    std::thread replay_thread_;
    std::atomic<bool> running_{false};

    // Event queue for fills generated by the replay thread
    mutable std::mutex event_mutex_;
    std::vector<EngineEvent> pending_events_;

    // RNG for fill probability
    mutable std::mt19937 rng_{std::random_device{}()};

    void replayLoop();

    // Process a replayed MDP3 packet - update BBOs, check for fills
    void processReplayedPacket(const char* data, size_t len);

    // Update BBO from MDIncrementalRefreshBook46
    void updateBBO(const sbe::MDIncrementalRefreshBook46& msg);

    // Check if any resting orders should be filled based on replayed trades
    std::vector<EngineEvent> checkFillsOnTrade(SecurityId security_id, Price trade_price, Quantity trade_qty, Side aggressor_side);

    // Check if order is immediately marketable
    bool isMarketable(const Order& order, const BBO& bbo) const;

    // Generate a synthetic fill
    EngineEvent generateFill(Order& order, Price fill_price, Quantity fill_qty);

    // Random fill probability check
    bool shouldFill() const;

    // Get current timestamp in nanoseconds
    static Timestamp nowNs();
};

} // namespace cme::sim
